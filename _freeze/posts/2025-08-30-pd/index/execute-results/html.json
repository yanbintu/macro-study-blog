{
  "hash": "b4867363afd71b1f56376fb4399b537b",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Phase Diagram\"\nauthor: \"Tu\"\ndate: \"2025-08-29\"\ncategories: [macro, code, visualization]\nexecute:\n  enabled: true\n---\n\nPhase diagram 是用来可视化系统随时间演化的绝佳手段，这里我们通过可视化经济学经典的RCK模型来说明 phase diagram 的含义。\n\n一个典型的RCK模型最终的一般均衡结果通常可以由下述的微分方程组描述\n\n$$\n\\begin{align*}\n    \\dot{k}(t) &= f(k(t)) - (n + g)k(t) - c(t) \\\\\n    \\dot{c}(t) &= c(t)(f'(k(t)) - \\rho - g) \\\\[1ex]\n    \\text{with} \\enspace &k(0) = k_0 > 0, \\enspace \\lim_{t \\to \\infty} k(t) \\exp(-\\int_{0}^{t} (f'(k(s)) - n - g) \\, ds) = 0 \\\\\n    &k(t) \\ge 0, \\enspace c(t) \\ge 0\n\\end{align*}\n$$ {#eq-01}\n\n这个两变量的一阶微分方程组实际上定义了一个从 $\\mathbb{R}_+^2$ 到 $\\mathbb{R}^2$ 的映射，即给定任意的 $(k,c)\\in\\mathbb{R}_+^2$， 对应于一个新的向量 $(\\dot{k},\\dot{c})\\in\\mathbb{R}^2$。 从几何的角度来看，这正是一个向量场：想象每一个二维平面正象限的点上都附着了一个新的向量，这个向量正好是 $k(t)$ 和 $c(t)$ 对时间的导数，因此这个向量的方向决定了这个点当前运动的方向，这个向量的大小决定了这个点运动速度的大小。\n\n我们使用[`quiver()`](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.quiver.html)将这一向量场在一个二维平面上可视化出来：\n\n::: {#42a43ab5 .cell execution_count=1}\n``` {.python .cell-code}\n# %%\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\nfrom numpy.linalg import eig\nfrom matplotlib.animation import FuncAnimation\nimport warnings\n\n# 忽略 Matplotlib 可能产生的一些用户警告\nwarnings.filterwarnings(\"ignore\", category=UserWarning)\n\n# 确保 Pillow 库已安装\ntry:\n    import PIL\nexcept ImportError:\n    print(\"请安装 Pillow 库: pip install Pillow\")\n    exit()\n\n# 提高 Agg 后端的内存限制，以处理复杂的动画帧\nplt.rcParams['agg.path.chunksize'] = 10000\n\n# %%\n# 定义微分方程组\ndef rck(state, t, alpha, rho, n, g):\n    k, c = state\n\n    # 添加安全检查，防止 k 变为负数导致数学错误\n    if k <= 0:\n        return [0, 0] # 如果 k 非正，则停止运动\n    \n    dkdt = k**alpha - c - (n + g)*k\n    dcdt = c*(alpha*k**(alpha-1) - rho - g)\n    return [dkdt, dcdt]\n\n# %%\n# 定义参数\nalpha, rho, n, g = 0.3, 0.03, 0.02, 0.02\n\n# %%\n# 计算稳态\nk_right = (1/(n+g))**(1/(1-alpha))\nk_gloden = (alpha/(n+g))**(1/(1-alpha))\nc_gloden = k_gloden**alpha - (n + g)*k_gloden\nk_star = (alpha / (rho + g))**(1 / (1 - alpha))\nc_star = k_star**alpha - (n + g) * k_star\n\n# %%\n# 计算 Jacobian 矩阵及其特征值和特征向量\ndef rck_jacobian(k, c, alpha, rho, n, g):\n    # 计算雅可比矩阵的四个元素\n    dk_dot_dk = alpha * k**(alpha - 1) - (n + g)\n    dk_dot_dc = -1.0\n    \n    dc_dot_dk = c * (alpha * (alpha - 1) * k**(alpha - 2))\n    # 在稳态处，(alpha*k**(alpha-1) - rho - delta - theta*g) = 0\n    # 所以 dc_dot/dc = 0，这是 RCK 线性化的一个特点\n    dc_dot_dc = 0.0 \n    \n    return np.array([[dk_dot_dk, dk_dot_dc], [dc_dot_dk, dc_dot_dc]])\n\n#在稳态点计算雅可比矩阵\nJ = rck_jacobian(k_star, c_star, alpha, rho, n, g)\n\n# 计算特征值和特征向量\neigenvalues, eigenvectors = eig(J)\n\n# 找到稳定特征向量 (与负特征值对应的那个)\nstable_eigenvector = eigenvectors[:, np.argmin(eigenvalues)]\n\n# %%\n# 计算 saddle path\nsaddle_point = [k_star, c_star]\nt_backward = np.linspace(0, -100, 600)\npath_saddle_up = odeint(rck, saddle_point + 0.1 * stable_eigenvector, t_backward, args=(alpha, rho, n, g))\npath_saddle_down = odeint(rck, saddle_point - 0.1 * stable_eigenvector, t_backward, args=(alpha, rho, n, g))\npath_saddle_up = np.flipud(path_saddle_up)\npath_saddle_down = np.flipud(path_saddle_down)\n\n# %%\n# 计算背景向量场\nk_grid = np.linspace(0.01, k_right*1.05, 20)\nc_grid = np.linspace(0.01, c_gloden*1.8, 20)\nK, C = np.meshgrid(k_grid, c_grid)\nu, v = np.zeros(K.shape), np.zeros(C.shape)\nfor i in range(K.shape[0]):\n    for j in range(K.shape[1]):\n        dkdt, dcdt = rck([K[i, j], C[i, j]], 0, alpha, rho, n, g)\n        u[i, j] = dkdt\n        v[i, j] = dcdt\n\n# 初始化图像，并设置背景为透明\nfig, ax = plt.subplots(figsize=(6, 5))\nfig.tight_layout()  # 调整边距\nfig.patch.set_alpha(0.0)\nax.patch.set_alpha(0.0)\nax.set_xlim(0, k_right*1.05)\nax.set_ylim(0, c_gloden*1.8)\nax.set_xlabel('k')\nax.set_ylabel('c')\n\n# %%\n# 绘制 loci：dkdt=0，dcdt=0\nx = np.linspace(0, k_right*1.05, 200)\ny = x**alpha - (n + g)*x\nax.plot(x, y, \n        color='black',\n        linestyle='-', \n        linewidth=1.5)\nax.axvline(x = k_star, color= 'black',linestyle='-', linewidth=1.5)\n\n# %%\n# 绘制 saddle path\nax.plot(path_saddle_up[:,0], path_saddle_up[:,1],\n        color='black',\n        linestyle='-', \n        linewidth=1.8)\n\nax.plot(path_saddle_down[:,0], path_saddle_down[:,1],\n        color='black',\n        linestyle='-', \n        linewidth=1.8)\n\n# 绘制向量场\nquiv = ax.quiver(K, C, u, v, \n                     color='gray', \n                     alpha=0.6,\n                     angles='xy',\n                     scale_units='xy',\n                     scale=0.5,\n                     width=0.005)\n\nplt.savefig('rck_quiver.png', bbox_inches='tight')\nplt.close(fig)\n```\n:::\n\n\n![](rck_quiver.png)\n\n想象我们向这个二维平面中抛入一个小球，图中的每一个箭头都指示了如果小球到达该位置时，这个小球接下来将会如何运动，箭头的大小则代表这一运动的相对速度有多快。\n\n当小球按照箭头连续地运动起来，它的的运动轨迹便构成了流线，我们使用streamplot将这些流线可视化：\n\n::: {#016b6108 .cell execution_count=2}\n``` {.python .cell-code}\n# %%\n# 计算背景向量场\nk_grid = np.linspace(0.01, k_right*1.05, 100)\nc_grid = np.linspace(0.01, c_gloden*1.8, 100)\nK, C = np.meshgrid(k_grid, c_grid)\nu, v = np.zeros(K.shape), np.zeros(C.shape)\nfor i in range(K.shape[0]):\n    for j in range(K.shape[1]):\n        dkdt, dcdt = rck([K[i, j], C[i, j]], 0, alpha, rho, n, g)\n        u[i, j] = dkdt\n        v[i, j] = dcdt\n\n# 初始化图像，并设置背景为透明\nfig, ax = plt.subplots(figsize=(6, 5))\nfig.tight_layout()  # 调整边距\nfig.patch.set_alpha(0.0)\nax.patch.set_alpha(0.0)\nax.set_xlim(0, k_right*1.05)\nax.set_ylim(0, c_gloden*1.8)\nax.set_xlabel('k')\nax.set_ylabel('c')\n\n# %%\n# 绘制 loci：dkdt=0，dcdt=0\nx = np.linspace(0, k_right*1.05, 200)\ny = x**alpha - (n + g)*x\nax.plot(x, y, \n        color='black',\n        linestyle='-', \n        linewidth=2)\nax.axvline(x = k_star, color= 'black',linestyle='-', linewidth=1.5)\n\n# %%\n# 绘制 saddle path\nax.plot(path_saddle_up[:,0], path_saddle_up[:,1],\n        color='black',\n        linestyle='-', \n        linewidth=1.8)\n\nax.plot(path_saddle_down[:,0], path_saddle_down[:,1],\n        color='black',\n        linestyle='-', \n        linewidth=1.8)\n\n# %%\n# 绘制流线图\nstrm = ax.streamplot(K, C, u, v, \n                     color=(0.4, 0.4, 0.4, 0.4), \n                     linewidth=1.2, \n                     density=1.2,)\n\nplt.savefig('rck_stream.png')\nplt.close(fig)\n```\n:::\n\n\n![](rck_stream.png)\n\n直观感受，此时的二维平面像是流动的液体，其流动的规则由我们的微分方程组描述。进一步，想象我们向其中抛入一堆小球，让我们用animation将这些小球的运动可视化：\n\n::: {#e4c66a15 .cell execution_count=3}\n``` {.python .cell-code}\n# %%\n# 计算粒子运动轨迹\n\n# 在 k 轴上从接近 0 到 k_max 创建 4 个均匀分布的点\nk_ticks = np.linspace(5, 60, 4)\n\n# 在 c 轴上从接近 0 到 c_max 创建 4 个均匀分布的点\nc_ticks = np.linspace(0.25, 2.5, 4)\n\n# K 和 C 都将是 4x4 的矩阵\nK_grid, C_grid = np.meshgrid(k_ticks, c_ticks)\n\n# K_grid.flatten() 会将 4x4 的 K 矩阵变成一个 16x1 的向量\n# C_grid.flatten() 会将 4x4 的 C 矩阵变成一个 16x1 的向量\nk_initial = K_grid.flatten()\nc_initial = C_grid.flatten()\n\n# 使用 column_stack 将它们合并成一个 16x2 的矩阵\ninitial_states = np.column_stack([k_initial, c_initial])\n\nt = np.linspace(0, 50, 300)\npaths = [odeint(rck, state, t, args=(alpha, rho, n, g)) for state in initial_states]\n\n# %%\npaths.append(path_saddle_up[100:400, :])\npaths.append(path_saddle_down[150:450, :])\n\n# %%\n# 创建动画元素和更新函数\nparticles, = ax.plot([], [], \"ro\", ms=4)\n\ndef update(frame):\n    x_data = [p[frame, 0] for p in paths]\n    y_data = [p[frame, 1] for p in paths]\n    particles.set_data(x_data, y_data)\n    return particles,\n\n# 创建动画对象\nani = FuncAnimation(fig, update, frames=len(t), interval=20, blit=True)\n\n# 保存动画为 APNG 文件\nani.save(\n    \"rck_animation.png\",\n    writer='pillow',\n    fps=50,\n    savefig_kwargs={'transparent': True, 'facecolor': 'none'}\n)\n```\n:::\n\n\n![](rck_animation.png)\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}