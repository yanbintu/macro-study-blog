[
  {
    "objectID": "posts/2025-09-08-lagrange-hamilton/index.html",
    "href": "posts/2025-09-08-lagrange-hamilton/index.html",
    "title": "从 Lagrange 到 Hamiltonian",
    "section": "",
    "text": "相较于严格陈述 Pontryagin’s maximum principle，通过类比离散时间的最优化问题并建立与连续时间情形的联系有时候可以提供更好的直觉。\n我们以一个离散时间的消费储蓄问题为例，为简化起见，假设利率以及消费者的收入都是常数：\n\n\\begin{align*}\n    &\\max_{ \\{c_t, a_{t+1}\\}_{t=0}^{\\infty} } \\sum_{t=0}^{\\infty} \\beta^t u(c_t) \\\\[1ex]\n    &\\text{s.t.} \\quad c_t + a_{t+1} = (1 + r)a_t + y \\enspace \\forall t \\ge 0, \\\\[1ex]\n    &\\ a_0 \\ \\text{is given} ,\\\\\n    &\\ \\text{nPg:} \\ \\lim_{T \\to \\infty} \\frac{a_{T+1}}{(1+r)^T} \\ge 0\n\\end{align*}\n\\tag{1}\n此时，我们可以构造标准的 Lagrange 函数并通过求一阶条件得到欧拉方程：\n\n\\mathcal{L} = \\sum_{t=0}^{\\infty} \\beta^t u(c_t) + \\sum_{t=0}^{\\infty} \\mu_t \\left( (1+r)a_t + w - c_t - a_{t+1} \\right)\n\\tag{2}\n但我们舍近求远，定义 Hamiltonian 如下：\n\n\\mathcal{H_t} \\equiv \\beta^t u(c_t) + \\mu_t(ra_t + w - c_t)\n\\tag{3}\n这时原 Lagrange (1) 可以改写为：\n\n\\mathcal{L} = \\sum_{t=0}^{\\infty} \\mathcal{H_t} + \\sum_{t=0}^{\\infty} \\mu_t \\left( a_t - a_{t+1} \\right)\n\\tag{4}\n此时对 c_t 求导得：\n\n\\frac{\\partial \\mathcal{H_t}}{\\partial c_t} = 0\n\\tag{5}\n对 a_t 求导得： \n\\frac{\\partial \\mathcal{H_t}}{\\partial a_t} = -(\\mu_t - \\mu_{t-1})\n\\tag{6}\n这里 -(\\mu_t - \\mu_{t-1}) 类比 -\\dot{\\mu_t}。\n对 \\mu_t 求导得：\n\n\\frac{\\partial \\mathcal{H_t}}{\\partial \\mu_t} = a_{t+1} - a_{t}\n\\tag{7}\n这里 a_{t+1} - a_{t} 类比 \\dot{a_t}。\nTVC:\n\n\\lim_{T \\to \\infty} \\mu_Ta_{T+1} = 0\n\\tag{8}\n注意到，我们已经得到了离散时间版本的 Pontryagin’s maximum principle。"
  },
  {
    "objectID": "posts/2025-08-30-nPg-ndl/index.html",
    "href": "posts/2025-08-30-nPg-ndl/index.html",
    "title": "No-Ponzi Game Condition and Natural Debt Limit",
    "section": "",
    "text": "庞氏骗局本质上描述的是通过借新债还旧债，并且只要还有人接盘，债务就会指数级越滚越大的模式。在无限期的动态经济学模型中，我们经常会看到所谓 no-Ponzi game condition 的身影，它的出现一开始并不自然，并且乍一看似乎与我们现实世界所认识的庞氏骗局并无直接联系。但下面的分析表明 no-Ponzi game condition 事实上刚好排除了上述那种借新还旧、债务无限增长的情况。\n进一步地，no-Ponzi game condition 更为深刻的含义在于它是联系 sequential trading equilibrium 和 Arrow-Debreu equilibrium 的重要条件。此外，在总收入现值有限的情况下，no-Ponzi game condition 等价于一个在直觉上更为自然的条件：natural debt limit 。\n\n1 三期的消费储蓄问题\n我们从一个标准的三期消费储蓄问题出发，消费者最大化他的效用：\n\n\\max_{\\{c_t, a_{t+1}\\}_{t=0}^2} u(c_0) + \\beta u(c_1) + \\beta^2 u(c_2),\n\\tag{1}\n消费者每一期相应地面临如下的预算约束：\n\n\\begin{align*}\n    c_0 + a_1 &= (1 + r_0)a_0 + y_0 \\\\\n    c_1 + a_2 &= (1 + r_1)a_1 + y_1 \\\\\n    c_2 + a_3 &= (1 + r_2)a_2 + y_2 \\\\\n\\end{align*}\n\\tag{2}\n通过简单的代数运算，消去 a_1、a_2，我们得到了消费者的一生预算约束：\n\nc_0 + \\frac{c_1}{1 + r_1} + \\frac{c_2}{(1 + r_1)(1 + r_2)} + \\frac{a_3}{(1 + r_1)(1 + r_2)} \\\\[2ex]\n= (1 + r_0)a_0 + y_0 + \\frac{y_1}{1 + r_1} + \\frac{y_2}{(1 + r_1)(1 + r_2)}\n\\tag{3}\n毫无疑问，(2)和(3)这两组约束条件在代数上是等价的，这并无任何奇特之处。但事实上，这两组约束条件可以分别代表两种不同的交易结构！\n(2)表达的是消费者在每一期都需要决定当期消费多少 c_t，并通过 a_{t+1} 决定储蓄多少带到下一期。因此这样的交易结构要求每一期都开放金融市场，这个金融市场中只交易一种简单的金融产品，在 t 期时购买1单位这样的证券会在 t+1 期带来 1+r_t 的回报。这样的交易结构实际上已经与我们现实中的交易方式比较接近了，以这样的交易结构定义的均衡称为 sequential trading equilibrium。\n(3)所内蕴的交易结构则与(2)完全不同，为了更清晰地看到这一点，让我们进行如下的定义：\n\n\\begin{align*}\n    p_1 &= \\frac{1}{1 + r_1} \\\\\n    p_2 &= \\frac{1}{(1 + r_1)(1 + r_2)}\n\\end{align*}\n\\tag{4}\n此时，(3)被重写为：\n\nc_0 + p_1c_1 + p_2c_2 + p_2a_3 = (1 + r_0)a_0 + y_0 + p_1y_1 + p_2y_2\n\\tag{5}\n这里 p_t 表示的是以0期的消费品为计价物的 t 期的消费品的价格，即1单位的 t 期消费品可以交换 p_t 单位的0期消费品。因此，上述的预算约束好像是在说，在整个经济的一开始，我们就将让所有的消费者面对面坐下来签订一个合同，通过议价的方式来交易不同时期的消费品，一旦合同敲定，后续将不再进行任何交易，而只按照一开始签好的合同进行执行。这里的关键是，我们将不同时期的消费品视作标准的、静态的一般均衡意义下的不同商品，这一概念还可以进一步推广到存在不确定性的经济，即将未来不同状态下的消费品视为可以进行交易的不同商品，这样的交易结构对应 Arrow-Debreu equilibrium。\n\n\n\n\n\n\nSequential trading equilibrium 和 Arrow-Debreu equilibrium 等价背后的隐含假设\n\n\n\n虽然在 sequential trading 的交易结构下消费者是在每一期进行消费和储蓄决策的，但不难发现为了实现一生的效用最大化，消费者必须在0期决策时就对未来的价格 r_1 和 r_2 有正确的预期，因此这里隐含地假设了理性预期，或者更合适的说法：消费者的预期是自我实现的。\n\n\n注意到，在我们不施加额外的约束时，上述的最优化问题不是良定义的。因为我们可以无限地增加债务（使得 a_3 趋向负无穷）来使得目标函数无限增加。由于第三期就是世界末日，没有消费者愿意在这时作为借出方，因此一个合理的额外约束是 a_3\\ge0 。此时(3)变为：\n\nc_0 + \\frac{c_1}{1 + r_1} + \\frac{c_2}{(1 + r_1)(1 + r_2)} \\le (1 + r_0)a_0 + y_0 + \\frac{y_1}{1 + r_1} + \\frac{y_2}{(1 + r_1)(1 + r_2)}\n\\tag{6}\n这正是经典的消费者一生的总支出不能超过消费者一生的总收入。\n由于消费者的效用函数是关于消费的严格单调增函数，最优时 a_3\\ge0 一定会 binding，因此有时会看到一些教材会直接假设 a_3=0。\n\n\n2 无限期的消费储蓄问题\n现在考虑无限期的消费储蓄问题，消费者面对的是如下最优化问题：\n\n\\begin{align*}\n    &\\max_{ \\{c_t, a_{t+1}\\}_{t=0}^{\\infty} } \\sum_{t=0}^{\\infty} \\beta^t u(c_t) \\\\[1ex]\n    &\\text{s.t.} \\quad c_t + a_{t+1} = (1 + r_t)a_t + y_t \\enspace \\forall t \\ge 0\n\\end{align*}\n\\tag{7}\n类似地，在不施加额外的约束时，上述优化问题不是良定义的，我们可以通过构造 Ponzi game 来使得消费达到任意大，具体构造如下：\n\n假设 \\{c_t^*, a_{t+1}^*\\}_{t=0}^{\\infty} 是最优解，令 c'_0 = c_0^* + \\epsilon，a'_1 = a_1^* - \\epsilon\n对所有 t \\ge 1，令 c'_t = c_t^*，a'_{t+1} = a_{t+1}^* - \\prod_{s=1}^t (1+r_s)\\epsilon\n\n由此，我们通过借新还旧的把戏凭空增加了一笔消费，且由于这是一个无限游戏，我们可以将这个把戏永无止境地进行下去，代价是我们的债务会以指数级的速度增长。\n为了排除上述的情况，或者说为了使我们无限期的优化问题是良定义的，我们必须施加额外的约束。受到有限期问题的启发，一个自然的想法是我们需要 \\lim_{T \\to \\infty} a_{T+1} \\ge 0。事实上，这的确可以使得我们的问题变得良定义，但问题在于这一约束过于强了。想象你在一开始完全没有任何收入（a_0=0，y_0=0）,但在那之后每一期你都会获得固定的收入 y_t = \\bar{y} \\enspace \\forall t \\ge 1，因此在期初你不得不借入一笔钱来维持生存，事实上你可以在每一期都借入 \\frac{\\bar{y}}{1+r}（简化起见，假设利率是一常数），此时 \\lim_{T \\to \\infty} a_{T+1} = \\frac{\\bar{y}}{1+r} &lt; 0，而这样的借贷模式毫无疑问应当是被允许的，因为消费者未来的收入永远可以还的上他的债务，且他的债务也不会爆炸增长。\n为此，我们希望引入一个最弱的使得我们的优化问题变得良定义的条件 no-Ponzi game condition，这个条件应当长什么样？关键是我们允许消费者在无穷远处有负债，但这一负债不能指数级地增长，因此一个合理的形式是：\n\n\\lim_{T \\to \\infty} \\frac{a_{T+1}}{\\prod_{t=1}^T (1 + r_t)} \\ge 0\n\\tag{8}\n可以验证，no-Ponzi game condition 的确排除了我们之前构造的 Ponzi game。\n事实上，与我们之前三期问题类似，这一不等式在最优时一定会 binding（Transversality condition），即 a_t^* 满足：\n\n\\lim_{T \\to \\infty} \\frac{a_{T+1}^*}{\\prod_{t=1}^T (1 + r_t)} = 0\n\\tag{9}\n因此，任何你试图额外增加的债务 \\epsilon 最终都会导致 \\lim_{T \\to \\infty} \\frac{a'_{T+1}}{\\prod_{t=1}^T (1 + r_t)} &lt; 0。\n\n\n\n\n\n\nNo-Ponzi game condition 和 Transversality condition\n\n\n\nNo-Ponzi game condition 和 Transversality condition 是在初学时极易混淆的两个条件。在我们当前的问题中，No-Ponzi game condition 是 \\lim_{T \\to \\infty} \\frac{a_{T+1}}{\\prod_{t=1}^T (1 + r_t)} \\ge 0，而 Transversality condition 是 \\lim_{T \\to \\infty} \\frac{a_{T+1}^*}{\\prod_{t=1}^T (1 + r_t)} = 0，尽管只相差一个不等号，但它们的意义完全不同。No-Ponzi game condition 是为了使得我们的优化问题良定义所施加的额外约束，因此它是假设；Transversality condition 是在我们施加了上述假设后，这个优化问题的最优解应当满足的必要条件，因此它是结果。\n\n\n类似地，我们也可以从 sequential trading equilibrium 和 Arrow-Debreu equilibrium 的等价性中自然地得到 no-Ponzi game condition。\n通过迭代消费者每期的预算约束至 T 期，得到：\n\n\\sum_{t=0}^{T} \\frac{c_t}{\\prod_{s=1}^{t}(1+r_s)} + \\frac{a_{T+1}}{\\prod_{s=1}^{T}(1+r_s)} = (1+r_0)a_0 + \\sum_{t=0}^{T} \\frac{w_t}{\\prod_{s=1}^{t}(1+r_s)}\n\\tag{10}\n令 T \\to \\infty：\n\n\\sum_{t=0}^{\\infty} \\frac{c_t}{\\prod_{s=1}^{t}(1+r_s)} + \\lim_{T \\to \\infty} \\frac{a_{T+1}}{\\prod_{t=1}^T (1 + r_t)} = (1+r_0)a_0 + \\sum_{t=0}^{\\infty} \\frac{w_t}{\\prod_{s=1}^{t}(1+r_s)}\n\\tag{11}\n此时 \\lim_{T \\to \\infty} \\frac{a_{T+1}}{\\prod_{t=1}^T (1 + r_t)} \\ge 0 等价于：\n\n\\sum_{t=0}^{\\infty} \\frac{c_t}{\\prod_{s=1}^{t}(1+r_s)} \\le (1+r_0)a_0 + \\sum_{t=0}^{\\infty} \\frac{w_t}{\\prod_{s=1}^{t}(1+r_s)}\n\\tag{12}\n再次，消费者一生的总支出不能超过消费者一生的总收入。\n\n\n3 Natural Debt Limit\n虽然 No-Ponzi game condition 是一个单一的终点条件，但它实际上隐含地规定了消费者每一期的借贷上限：\n\na_{t} \\ge - \\sum_{\\tau=t}^{\\infty} \\frac{w_{\\tau}}{\\prod_{s=t}^{\\tau}(1+r_s)}\n\\tag{13}\n这一借贷的上限称为 natural debt limit。这个条件事实上非常符合直觉，它表明消费者在任意一期的借贷都不能超过他未来所有收入的现值，因为只要一旦超过，那么消费者即使未来完全不消费，他未来的收入也不足够偿还他的债务，除非他开始玩借新还旧的把戏。\n在收入现值 \\sum_{t=0}^{\\infty} \\frac{w_t}{\\prod_{s=1}^{t}(1+r_s)} 是有限数的前提下，我们证明 natural debt limit 和 no-Ponzi game condition 等价。\n…"
  },
  {
    "objectID": "posts/2025-06-29-re-df/index.html",
    "href": "posts/2025-06-29-re-df/index.html",
    "title": "理性预期和差分方程",
    "section": "",
    "text": "当我们想要描述一个系统随时间的演化，微分方程和差分方程便自然地出现了。对于经典的物理系统而言，给定一组描述系统的方程和变量的初始值，该系统未来的动态便被唯一地确定了，这时我们说，这一系统是“决定论”的。\n但在经济系统中，事情则变得有些微妙起来，考虑如下具有前瞻性预期（forward-looking expectation）的差分方程： \ny_t = a\\mathbb{E}_t[ y_{t+1}] + bx_t\n上述方程形式常见于微观主体做最优化的一阶条件，它表明： y_t 当期值不仅决定于某些外生的因素 x_t，还决定于对该变量未来值的预期 \\mathbb{E}_t[y_{t+1}]。此时人的主观预期成为了一个系统状态重要的，甚至是决定性的因素！\n当人们都预期一家银行经营良好时，银行便会正常运行。但若因为一些外部事件，甚至可能仅仅是谣言导致储户的预期发生了改变，认为这家银行有倒闭的风险，这时挤兑便发生了，最终这家银行仅仅是由于人们主观上的预期改变而真的倒闭，即使它的客观财务状况本身没有任何问题。"
  },
  {
    "objectID": "posts/2025-06-29-re-df/index.html#type-ⅰ",
    "href": "posts/2025-06-29-re-df/index.html#type-ⅰ",
    "title": "理性预期和差分方程",
    "section": "1.1 Type Ⅰ",
    "text": "1.1 Type Ⅰ\n考虑如下的差分方程： \ny_t = a\\mathbb{E}_{t-1}^s[y_{t}] + bx_t\n\\tag{1}\n其中 y_t 是由该方程描述的内生变量，x_t 是给定的外生随机变量，服从某个已知的概率生成过程。这里 \\mathbb{E}_{t-1}^s[y_{t}] 加上了上标 s，表示这里的期望是主观（subjective）的，它表示的是人对未来的模糊感受，用以区分基于客观概率计算的数学期望 \\mathbb{E}_{t-1}[y_{t}]1。有些拗口地说：过去对当前系统状态的预期塑造了当前系统的实际状态。\n\n\n\n\n\n\n例1 Muth的水果市场\n\n\n\n考虑某种水果市场的局部均衡，假设消费者在t年对该水果的需求曲线如下： \nQ_{t}^{d} = -\\beta P_t\n\\tag{2} 果农在上一年决定这种水果的播种面积，具体种植多少，则取决于果农对明年市场价格的主观预期，预期的价格越高，果农选择播种的面积也就越大，相应的这种水果在 t 年的供给也就越多： \nQ_{t}^{s} = \\gamma\\mathbb{E}_{t-1}^s[P_{t}] + u_t\n\\tag{3}\n在简单的线性供给曲线之上，我们增加了一个随机扰动 u_t 用来刻画影响实际产量的随机因素，包括天气、土壤肥力波动等。上述所有参数都为正，并且为了后续计算方便，相应的变量都用其对均衡的偏离量来表示，因此没有截距项2。最后，由于水果显然不能存储到下一年，因此均衡时我们有：\n\nQ_{t}^{d} = Q_{t}^{s}\n\\tag{4}\n联立以上三式，我们就将 t 期真实的价格 P_t 表示为了主观预期 \\mathbb{E}_{t-1}^s[P_{t}] 的线性函数： \nP_{t} = -\\frac{\\gamma}{\\beta}\\mathbb{E}_{t-1}^s[P_{t}] - \\frac{1}{\\beta}u_t\n\\tag{5}\n而这一形式正对应于式(1)。"
  },
  {
    "objectID": "posts/2025-06-29-re-df/index.html#type-ⅱ",
    "href": "posts/2025-06-29-re-df/index.html#type-ⅱ",
    "title": "理性预期和差分方程",
    "section": "1.2 Type Ⅱ",
    "text": "1.2 Type Ⅱ\n我们在宏观经济学中更常见到的方程具有如下形式：\n\ny_t = a\\mathbb{E}_{t}^s[y_{t+1}] + bx_t\n\\tag{6}\n这一方程与之前的方程非常相似，唯一的区别是预期向未来迭代了一期，但却给模型的求解带来了很大的不同。通常，我们称这一类型的方程是forward-looking的，这充分反应了人是具有主观能动性的，而不是像机械一样服从固定规则运行的。经济人总是在当下和未来之间权衡，而未来是不确定的，从而预期就变得尤为重要。\n\n\n\n\n\n\n例2 风险中性定价\n\n\n\n在风险中性的世界中，投资者只关心股票的预期收益，而不关心其风险，因此根据无套利原理，股票带来的预期收益应当等于无风险利率： \n\\frac{\\mathbb{E}_{t}^s[P_{t+1}] + d_t - P_t}{P_t} = r_f\n\\tag{7}\n重新整理可得： \nP_t = \\frac{1}{1+r_f} \\mathbb{E}_{t}^s[P_{t+1}] + \\frac{1}{1+r_f} d_t\n\\tag{8}\n上式不过是在说当前的股票价格 P_t 等于对下一期股票价格的预期 \\mathbb{E}_{t}^s[P_{t+1}] 加上股票分红 d_t 后用无风险利率折现，而这一形式正对应于式(6)。"
  },
  {
    "objectID": "posts/2025-06-29-re-df/index.html#适应性预期",
    "href": "posts/2025-06-29-re-df/index.html#适应性预期",
    "title": "理性预期和差分方程",
    "section": "2.1 适应性预期",
    "text": "2.1 适应性预期\n有时候我们会在市场上观察到一种现象，某一年的某种水果因为天气等原因导致产量较低，市场供不应求，价格上涨。这使得果农受到激励，扩大播种面积，导致第二年供过于求，价格下跌。经历了第二年的亏损，果农又减少了该品种的种植面积，这又导致第三年供不应求，如此循环往复，价格呈现出周期性的波动。\n套用我们的例1，上面的故事不过是在说 \\mathbb{E}_{t-1}^s[y_{t}] = y_{t-1} ，即果农直接将当期的价格作为下一期价格的预期。稍作修改我们就得到了所谓的外推型预期（extrapolative expectation）：\\mathbb{E}_{t-1}^s[y_{t}] = y_{t-1} + \\sigma(y_{t-1} - y_{t-2})，即如果今年水果价格相对去年上涨，果农认为这种上涨趋势会在明年持续。但按照上述的逻辑，果农很快会发现自己的预期总是错误的，如果果农并没有那么“笨”，那么他应当会根据自己之前的错误来调整自己的预期，这便引出了适应性预期（adaptive expectation）的概念： \n\\mathbb{E}_{t-1}^s[y_{t}] = \\mathbb{E}_{t-2}^s[y_{t-1}] + \\delta(y_{t-1} - \\mathbb{E}_{t-2}^s[y_{t-1}])\n\\tag{9}\n如果 y_{t-1} 大于 \\mathbb{E}_{t-2}^s[y_{t-1}]，说明过去的预期相对低估了，相应的明年的预期就应当上调，调整的强度取决于系数 \\delta。\n将式(9)适当重写得到 \n\\mathbb{E}_{t-1}^s[y_{t}] = \\delta y_{t-1} + (1 - \\delta)\\mathbb{E}_{t-2}^s[y_{t-1}]\n\\tag{10}\n进一步地，我们向后迭代，得到 \n\\begin{align}\n\\mathbb{E}_{t-1}^s[y_{t}] &= \\delta y_{t-1} + (1 - \\delta)(\\delta y_{t-2} + (1-\\delta)\\mathbb{E}_{t-3}^s[y_{t-2}]) \\\\\n&= \\delta y_{t-1} + \\delta(1-\\delta) y_{t-2} + (1-\\delta)^2 \\mathbb{E}_{t-3}^s[y_{t-2}] \\\\\n&\\cdots \\\\\n&= \\delta(y_{t-1} + (1-\\delta)y_{t-2} + (1-\\delta)^2 y_{t-3} + \\cdots)\n\\end{align}\n\\tag{11}\n这里，我们假设了当 n \\to \\infty 时，\\mathbb{E}_{t-n-1}^s[y_{t-n}] 是有限的。因此适应性预期等价于假设预期是过去所有历史值的加权平均。上述所有的预期形成方式可以总结为 $$\n$$ {#eq-12}"
  },
  {
    "objectID": "posts/2025-06-29-re-df/index.html#理性预期",
    "href": "posts/2025-06-29-re-df/index.html#理性预期",
    "title": "理性预期和差分方程",
    "section": "2.2 理性预期",
    "text": "2.2 理性预期"
  },
  {
    "objectID": "posts/2025-06-29-re-df/index.html#footnotes",
    "href": "posts/2025-06-29-re-df/index.html#footnotes",
    "title": "理性预期和差分方程",
    "section": "Footnotes",
    "text": "Footnotes\n\n\n这一区分的作用将会在后文变得清晰。↩︎\n考虑原始模型为 Q_{t} = \\alpha+ \\beta P_t 包含截距项,均衡时有 \\bar{Q} = \\alpha+ \\beta \\bar{P}，两式相减即消去 \\alpha，但相应的变量转变为对均衡量的偏离。↩︎"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "本站内容由人工智障生成，请谨慎甄别"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Macro",
    "section": "",
    "text": "Overview: Dynamic Optimization in Macro\n\n\n\nmacro\n\n\n\n\n\n\n\n\n\nOct 3, 2025\n\n\nTu\n\n\n\n\n\n\n\n\n\n\n\n\nRubin因果模型：一个符号上的Tip\n\n\n\nmetrics\n\n\n\n\n\n\n\n\n\nSep 15, 2025\n\n\nTu\n\n\n\n\n\n\n\n\n\n\n\n\n从 Lagrangian 到 Hamiltonian\n\n\n\nmacro\n\n\n\n\n\n\n\n\n\nSep 8, 2025\n\n\nTu\n\n\n\n\n\n\n\n\n\n\n\n\nPhase Diagram\n\n\n\nmacro\n\ncode\n\nvisualization\n\n\n\n\n\n\n\n\n\nSep 4, 2025\n\n\nTu\n\n\n\n\n\n\n\n\n\n\n\n\nNo-Ponzi Game Condition and Natural Debt Limit\n\n\n\nmacro\n\n\n\n\n\n\n\n\n\nAug 30, 2025\n\n\nTu\n\n\n\n\n\n\n\n\n\n\n\n\nBlanchard-Kahn Condition\n\n\n\nmacro\n\n\n\n\n\n\n\n\n\nJul 10, 2025\n\n\nTu\n\n\n\n\n\n\n\n\n\n\n\n\n理性预期和差分方程\n\n\n\nmacro\n\n\n\n\n\n\n\n\n\nJun 29, 2025\n\n\nTu\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/2025-07-10-bkc/index.html",
    "href": "posts/2025-07-10-bkc/index.html",
    "title": "Blanchard-Kahn Condition",
    "section": "",
    "text": "当假设了理性预期后，求解带期望的线性差分方程转变为一个纯粹的数学问题，这里的复杂度在于我们求解的目标不再是一个数列，而是一个随机变量序列。因此，我们首先从一维情形出发，然后考虑二维情形，最后过渡到一般的多维情形。\n\n1 一维情形\n让我们从一个最 trivial 的没有不确定性的例子出发：\n\ny_{t+1} = \\lambda y_{t}\n\\tag{1}\n(1)就是一个标准的一维线性差分方程，那么什么叫做这样一个方程的解？Mathematically，我们就是要找到一个无穷序列 \\{y_t\\}_{t=0}^{\\infty} 使得它满足(1)。\n显然，如果不给定额外的初始条件，有无穷多的 \\{y_t\\}_{t=0}^{\\infty} 都可以满足(1)，此时我们说无法确定一个唯一的解。只要任意给定一个初始条件，例如给定 y_0 = \\bar{y}，那么通过后向迭代的方式，方程的解就唯一确定为 y_t = {\\lambda}^t \\bar{y} \\enspace \\forall t \\ge 0。\n我们还可以给定终点条件 \\lim_{t \\to \\infty } y_t &lt; \\infty，此时我们能唯一确定一个解吗？答案取决于 \\lambda 的取值，如果 \\lambda \\le 1，那么从任何一个初始值 y_0 出发，都有 \\lim_{t \\to \\infty } {\\lambda}^t y_0 &lt; \\infty，因此此时即使额外增加一个终点条件仍然不能确定一个唯一的解。当 \\lambda \\gt 1，由于此时给定的是终点条件，所以自然地我们需要前向迭代，令 \\phi = 1/\\lambda，将(1)重写为：\n\ny_{t} = \\phi y_{t+1}\n\\tag{2}\n前向迭代，得到 y_t = {\\phi}^s y_{t+s}，令 s \\to \\infty，由于此时 \\phi \\lt 0，应用我们的终点条件 \\lim_{t \\to \\infty } y_t &lt; \\infty，得到 y_t = 0 \\enspace \\forall t \\ge 0。因此当 \\lambda \\gt 1，终点条件也唯一确定了一个解，尽管这个解显得非常 trivial。特别的，这个终点条件反过来决定了我们的初始值 y_0 必须等于0。\n现在考虑存在不确定性的情形：\n\n\\mathbb{E}_t[y_{t+1}] = \\lambda y_{t}\n\\tag{3}\n那么什么叫做一个带期望的线性差分方程的解？Mathematically，我们此时需要找的不再是一个实数序列，而是一个随机变量序列 \\{y_t\\}_{t=0}^{\\infty}，同时回顾概率论的基本知识，随机变量实际上是定义在样本空间 \\Omega 的函数，因此我们真正的问题是：找到一个定义在样本空间 \\Omega 的函数序列 \\{y_t(\\cdot)\\}_{t=0}^{\\infty} 满足(3)\n因此严格来说，我们还需要指定一个概率空间 (\\Omega, \\mathbb{F}, P) 才能完整地描述上述的问题，但在我们目前线性的简单情形下，概率空间 (\\Omega, \\mathbb{F}, P) 的具体性质并不影响我们求解。\n对于(3)，给定初始条件 y_0 = \\bar{y}，能否确定一个唯一的解？答案是否定的，实际上我们可以有无穷多的随机变量序列满足条件：\n\n假设现已找到一个解 \\{y_t\\}_{t=0}^{\\infty} 满足(3)，且满足 y_0 = \\bar{y}。\n对所有 t \\ge 1，令 y'_{t} = y_{t} + \\epsilon_t，y'_0 = y_0。容易验证，\\{y'_t\\}_{t=0}^{\\infty} 也是一个解只要 \\mathbb{E}_t[\\epsilon_{t+1}] = \\lambda \\epsilon_{t}。\n\n相反，此时如果给定终点条件 \\lim_{s \\to \\infty } \\mathbb{E}_t[y_{t+s}] &lt; \\infty，什么时候有唯一解？当 \\lambda \\le 1 时，与我们给定初始条件的论证完全类似地，此时我们的解仍然是未定的。当 \\lambda \\gt 1，让我们类似地将(3)重写为：\n\ny_{t} = \\phi \\mathbb{E}_t[y_{t+1}]\n\\tag{4}\n前向迭代并应用迭条件期望定律，得到 y_{t} = \\phi^s \\mathbb{E}_t[y_{t+s}]，令 s \\to \\infty，得到 y_t = 0 \\enspace \\forall t \\ge 0。需要注意的是，此时的 y_t 并不是实数0，而是定义在样本空间 \\Omega 上的零函数。\n宏观经济学通常会假设随机性来源于外生的随机过程，例如：\n\ny_{t} = \\phi \\mathbb{E}_t[y_{t+1}] + x_t\n\\tag{5}\nx_t 一般假设服从一个AR(1)过程：\n\nx_{t} = \\rho x_{t-1} + u_{t}\n\\tag{6}\n与之前的论证类似，此时方程存在唯一解的条件仍然是 \\phi &lt; 1（\\lambda &gt; 1），但知道了模型具有唯一解后，这个解应当具有什么样的形式？这里的关键在于，现在我们模型潜在的那个概率空间正是由我们外生的随机过程 \\{x_t\\}_{t=0}^{\\infty} 所定义，因此最终我们的解 y_t 将会是 x_t 的函数，又由于方程的线性性，最终解的形式一定是 y_t = \\alpha x_t，这正是为什么我们可以应用“猜测法”的原因。\n现在唯一的待定系数只剩下 \\alpha，让我们将 y_t = \\alpha x_t 带入 (5)：\n\n\\begin{align*}\n\\alpha x_t &= \\phi \\mathbb{E}_t[\\alpha (\\rho x_t + u_{t+1})] + x_t \\\\\n\\alpha x_t &= \\phi \\alpha \\rho x_t + x_t \\\\\n\\alpha x_t &= (1 + \\phi \\rho \\alpha) x_t\n\\end{align*}\n\\tag{7}\n由于上述等式需要对所有 x_t 成立，因此有:\n\n\\alpha = 1 + \\phi \\rho \\alpha\n\\tag{8}\n解得 \\alpha = \\frac{1}{1 - \\phi \\rho}。\n事实上，我们仍然可以使用之前的前向迭代法来验证我们的猜测法是否正确：\n\n\n2 二维情形\n\n\n3 一般情形"
  },
  {
    "objectID": "posts/2025-09-04-phase-diagram/index.html",
    "href": "posts/2025-09-04-phase-diagram/index.html",
    "title": "Phase Diagram",
    "section": "",
    "text": "Phase diagram 是用来可视化系统随时间演化的绝佳手段，这里我们通过可视化经济学经典的RCK模型来说明 phase diagram 的含义。\n一个典型的连续时间新古典增长模型最终的一般均衡结果通常可以由下述的微分方程组描述：\n\n\\begin{align*}\n    \\dot{k}(t) &= f(k(t)) - (n + g)k(t) - c(t) \\\\\n    \\dot{c}(t) &= c(t)(f'(k(t)) - \\rho - g) \\\\[1ex]\n    \\text{with} \\enspace &k(0) = k_0 &gt; 0, \\enspace \\lim_{t \\to \\infty} k(t) \\exp(-\\int_{0}^{t} (f'(k(s)) - n - g) \\, ds) = 0 \\\\\n    &k(t) \\ge 0, \\enspace c(t) \\ge 0\n\\end{align*}\n\\tag{1}\n这个两变量的一阶微分方程组实际上定义了一个从 \\mathbb{R}_+^2 到 \\mathbb{R}^2 的映射，即给定任意的 (k, c)\\in\\mathbb{R}_+^2， 对应于一个新的向量 (\\dot{k},\\dot{c})\\in\\mathbb{R}^2。 从几何的角度来看，这正是一个向量场：想象每一个二维平面正象限的点上都附着了一个新的向量，这个向量正好是 k(t) 和 c(t) 对时间的导数，因此这个向量的方向决定了这个点当前运动的方向，这个向量的大小决定了这个点运动速度的大小。\n我们使用quiver()将这一向量场在 (k, c) 所在的二维平面上可视化出来：\n\n\nCode\n# %%\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\nfrom numpy.linalg import eig\nfrom matplotlib.animation import FuncAnimation\nimport warnings\n\n# 忽略 Matplotlib 可能产生的一些用户警告\nwarnings.filterwarnings(\"ignore\", category=UserWarning)\n\n# 确保 Pillow 库已安装\ntry:\n    import PIL\nexcept ImportError:\n    print(\"请安装 Pillow 库: pip install Pillow\")\n    exit()\n\n# 提高 Agg 后端的内存限制，以处理复杂的动画帧\nplt.rcParams['agg.path.chunksize'] = 10000\n\n# %%\n# 定义微分方程组\ndef rck(state, t, alpha, rho, n, g):\n    k, c = state\n\n    # 添加安全检查，防止 k 变为负数导致数学错误\n    if k &lt;= 0:\n        return [0, 0] # 如果 k 非正，则停止运动\n    \n    dkdt = k**alpha - c - (n + g)*k\n    dcdt = c*(alpha*k**(alpha-1) - rho - g)\n    return [dkdt, dcdt]\n\n# %%\n# 定义参数\nalpha, rho, n, g = 0.3, 0.03, 0.02, 0.02\n\n# %%\n# 计算稳态\nk_right = (1/(n+g))**(1/(1-alpha))\nk_gloden = (alpha/(n+g))**(1/(1-alpha))\nc_gloden = k_gloden**alpha - (n + g)*k_gloden\nk_star = (alpha / (rho + g))**(1 / (1 - alpha))\nc_star = k_star**alpha - (n + g) * k_star\n\n# %%\n# 计算 Jacobian 矩阵及其特征值和特征向量\ndef rck_jacobian(k, c, alpha, rho, n, g):\n    # 计算雅可比矩阵的四个元素\n    dk_dot_dk = alpha * k**(alpha - 1) - (n + g)\n    dk_dot_dc = -1.0\n    \n    dc_dot_dk = c * (alpha * (alpha - 1) * k**(alpha - 2))\n    # 在稳态处，(alpha*k**(alpha-1) - rho - delta - theta*g) = 0\n    # 所以 dc_dot/dc = 0，这是 RCK 线性化的一个特点\n    dc_dot_dc = 0.0 \n    \n    return np.array([[dk_dot_dk, dk_dot_dc], [dc_dot_dk, dc_dot_dc]])\n\n#在稳态点计算雅可比矩阵\nJ = rck_jacobian(k_star, c_star, alpha, rho, n, g)\n\n# 计算特征值和特征向量\neigenvalues, eigenvectors = eig(J)\n\n# 找到稳定特征向量 (与负特征值对应的那个)\nstable_eigenvector = eigenvectors[:, np.argmin(eigenvalues)]\n\n# %%\n# 计算 saddle path\nsaddle_point = [k_star, c_star]\nt_backward = np.linspace(0, -100, 600)\npath_saddle_up = odeint(rck, saddle_point + 0.1 * stable_eigenvector, t_backward, args=(alpha, rho, n, g))\npath_saddle_down = odeint(rck, saddle_point - 0.1 * stable_eigenvector, t_backward, args=(alpha, rho, n, g))\npath_saddle_up = np.flipud(path_saddle_up)\npath_saddle_down = np.flipud(path_saddle_down)\n\n# %%\n# 计算背景向量场\nk_grid = np.linspace(0.01, k_right*1.05, 20)\nc_grid = np.linspace(0.01, c_gloden*1.8, 20)\nK, C = np.meshgrid(k_grid, c_grid)\nu, v = np.zeros(K.shape), np.zeros(C.shape)\nfor i in range(K.shape[0]):\n    for j in range(K.shape[1]):\n        dkdt, dcdt = rck([K[i, j], C[i, j]], 0, alpha, rho, n, g)\n        u[i, j] = dkdt\n        v[i, j] = dcdt\n\n# 初始化图像，并设置背景为透明\nfig, ax = plt.subplots(figsize=(6, 5))\nfig.tight_layout()  # 调整边距\nfig.patch.set_alpha(0.0)\nax.patch.set_alpha(0.0)\nax.set_xlim(0, k_right*1.05)\nax.set_ylim(0, c_gloden*1.8)\nax.set_xlabel('k')\nax.set_ylabel('c')\n\n# %%\n# 绘制 loci：dkdt=0，dcdt=0\nx = np.linspace(0, k_right*1.05, 200)\ny = x**alpha - (n + g)*x\nax.plot(x, y, \n        color='black',\n        linestyle='-', \n        linewidth=1.5)\nax.axvline(x = k_star, color= 'black',linestyle='-', linewidth=1.5)\n\n# %%\n# 绘制 saddle path\nax.plot(path_saddle_up[:,0], path_saddle_up[:,1],\n        color='black',\n        linestyle='-', \n        linewidth=1.8)\n\nax.plot(path_saddle_down[:,0], path_saddle_down[:,1],\n        color='black',\n        linestyle='-', \n        linewidth=1.8)\n\n# 绘制向量场\nquiv = ax.quiver(K, C, u, v, \n                     color='gray', \n                     alpha=0.6,\n                     angles='xy',\n                     scale_units='xy',\n                     scale=0.5,\n                     width=0.005)\n\nplt.savefig('rck_quiver.png', bbox_inches='tight')\nplt.close(fig)\n\n\n\n想象我们向这个二维平面中抛入一个小球，图中的每一个箭头都指示了如果小球到达该位置时，这个小球接下来将会如何运动。当小球按照箭头连续地运动起来，它的的运动轨迹便构成了流线，我们使用streamplot()将这些流线可视化：\n\n\nCode\n# %%\n# 计算背景向量场\nk_grid = np.linspace(0.01, k_right*1.05, 100)\nc_grid = np.linspace(0.01, c_gloden*1.8, 100)\nK, C = np.meshgrid(k_grid, c_grid)\nu, v = np.zeros(K.shape), np.zeros(C.shape)\nfor i in range(K.shape[0]):\n    for j in range(K.shape[1]):\n        dkdt, dcdt = rck([K[i, j], C[i, j]], 0, alpha, rho, n, g)\n        u[i, j] = dkdt\n        v[i, j] = dcdt\n\n# 初始化图像，并设置背景为透明\nfig, ax = plt.subplots(figsize=(6, 5))\nfig.tight_layout()  # 调整边距\nfig.patch.set_alpha(0.0)\nax.patch.set_alpha(0.0)\nax.set_xlim(0, k_right*1.05)\nax.set_ylim(0, c_gloden*1.8)\nax.set_xlabel('k')\nax.set_ylabel('c')\n\n# %%\n# 绘制 loci：dkdt=0，dcdt=0\nx = np.linspace(0, k_right*1.05, 200)\ny = x**alpha - (n + g)*x\nax.plot(x, y, \n        color='black',\n        linestyle='-', \n        linewidth=2)\nax.axvline(x = k_star, color= 'black',linestyle='-', linewidth=1.5)\n\n# %%\n# 绘制 saddle path\nax.plot(path_saddle_up[:,0], path_saddle_up[:,1],\n        color='black',\n        linestyle='-', \n        linewidth=1.8)\n\nax.plot(path_saddle_down[:,0], path_saddle_down[:,1],\n        color='black',\n        linestyle='-', \n        linewidth=1.8)\n\n# %%\n# 绘制流线图\nstrm = ax.streamplot(K, C, u, v, \n                     color=(0.4, 0.4, 0.4, 0.4), \n                     linewidth=1.2, \n                     density=1.2,)\n\nplt.savefig('rck_stream.png')\nplt.close(fig)\n\n\n\n直观感受，此时的二维平面像是充满了流动的液体，其流动的规则由我们的微分方程组描述。进一步，想象我们向其中抛入一堆小球，让我们用FuncAnimation()将这些小球的运动可视化：\n\n\nCode\n# %%\n# 计算粒子运动轨迹\n\n# 在 k 轴上从接近 0 到 k_max 创建 4 个均匀分布的点\nk_ticks = np.linspace(5, 60, 4)\n\n# 在 c 轴上从接近 0 到 c_max 创建 4 个均匀分布的点\nc_ticks = np.linspace(0.25, 2.5, 4)\n\n# K 和 C 都将是 4x4 的矩阵\nK_grid, C_grid = np.meshgrid(k_ticks, c_ticks)\n\n# K_grid.flatten() 会将 4x4 的 K 矩阵变成一个 16x1 的向量\n# C_grid.flatten() 会将 4x4 的 C 矩阵变成一个 16x1 的向量\nk_initial = K_grid.flatten()\nc_initial = C_grid.flatten()\n\n# 使用 column_stack 将它们合并成一个 16x2 的矩阵\ninitial_states = np.column_stack([k_initial, c_initial])\n\nt = np.linspace(0, 50, 300)\npaths = [odeint(rck, state, t, args=(alpha, rho, n, g)) for state in initial_states]\n\n# %%\npaths.append(path_saddle_up[100:400, :])\npaths.append(path_saddle_down[150:450, :])\n\n# %%\n# 创建动画元素和更新函数\nparticles, = ax.plot([], [], \"ro\", ms=4)\n\ndef update(frame):\n    x_data = [p[frame, 0] for p in paths]\n    y_data = [p[frame, 1] for p in paths]\n    particles.set_data(x_data, y_data)\n    return particles,\n\n# 创建动画对象\nani = FuncAnimation(fig, update, frames=len(t), interval=20, blit=True)\n\n# 保存动画为 APNG 文件\nani.save(\n    \"rck_animation.png\",\n    writer='pillow',\n    fps=50,\n    savefig_kwargs={'transparent': True, 'facecolor': 'none'}\n)\n\n\n\n目前为止我们只用到了我们完整的均衡描述(1)的前两个运动方程，即任意给定小球的初始位置 (k(0),c(0))\\in\\mathbb{R}_+^2，小球会如何运动下去。换言之，图中任何一个小球的运动轨迹都是这个微分方程组的解，对于这个两变量的一阶微分方程组，我们需要给定两个初始条件才能唯一地确定一个解。\n但注意到，我们RCK模型的解的描述中似乎只有一个初始条件 k(0)=k_0 &gt; 0，另一个初始条件是什么？答案是 \\lim_{t \\to \\infty} k(t) \\exp(-\\int_{0}^{t} (f'(k(s)) - n - g) \\, ds) = 0，虽然将之称为边界条件或者终点条件更为合适，但它确实也是某种意义上的“初始条件”。事实上，对于任意给定的初始资本 k(0)=k_0 &gt; 0 ，这个边界条件反过来唯一地确定了初始消费 c(0) 的取值，这唯一的对应关系构成了从状态变量 k 到控制变量 c 的对应关系 c=g(k)，称之为 policy function，体现在图中便是我们的 saddle path，这背后是家庭的最优化行为。\n从图中可以很清晰地看到，任何在 saddle path 上方的小球最终会运动到左上角，任何在 saddle path 下方的小球最终会运动到右下角，他们看起来都是不合理的解，只有刚好在 saddle path 上的小球最终会沿着这条唯一确定的最优路径抵达稳态，值得注意的是即使是初始值非常微小的偏差，最终也会发散。\n虽然左上角和右下角直觉上都是不合理的区域，但我们最终一般均衡的描述(1)应当自包含了唯一正确的解，如何严格排除其他不合理的解？\n可以验证：\n\n右下角最终会违反 \\lim_{t \\to \\infty} k(t) \\exp(-\\int_{0}^{t} (f'(k(s)) - n - g) \\, ds) = 0\n左上角最终会使得 k(t) 为负，违反了物理约束 k(t) \\ge 0"
  },
  {
    "objectID": "posts/2025-09-08-lagrange-hamilton copy/index.html",
    "href": "posts/2025-09-08-lagrange-hamilton copy/index.html",
    "title": "从 Lagrange 到 Hamiltonian",
    "section": "",
    "text": "相较于严格陈述 Pontryagin’s maximum principle，通过类比离散时间的最优化问题并建立与连续时间情形的联系有时候可以提供更好的直觉。\n我们以一个离散时间的消费储蓄问题为例，为简化起见，假设利率以及消费者的收入都是常数：\n\n\\begin{align*}\n    &\\max_{ \\{c_t, a_{t+1}\\}_{t=0}^{\\infty} } \\sum_{t=0}^{\\infty} \\beta^t u(c_t) \\\\[1ex]\n    &\\text{s.t.} \\quad c_t + a_{t+1} = (1 + r)a_t + y \\enspace \\forall t \\ge 0, \\\\[1ex]\n    &\\ a_0 \\ \\text{is given} ,\\\\\n    &\\ \\text{nPg:} \\ \\lim_{T \\to \\infty} \\frac{a_{T+1}}{(1+r)^T} \\ge 0\n\\end{align*}\n\\tag{1}\n此时，我们可以构造标准的 Lagrange 函数并通过求一阶条件得到欧拉方程：\n\n\\mathcal{L} = \\sum_{t=0}^{\\infty} \\beta^t u(c_t) + \\sum_{t=0}^{\\infty} \\mu_t \\left( (1+r)a_t + w - c_t - a_{t+1} \\right)\n\\tag{2}\n但我们舍近求远，定义 Hamiltonian 如下：\n\n\\mathcal{H_t} \\equiv \\beta^t u(c_t) + \\mu_t(ra_t + w - c_t)\n\\tag{3}\n这时原 Lagrange (1) 可以改写为：\n\n\\mathcal{L} = \\sum_{t=0}^{\\infty} \\mathcal{H_t} + \\sum_{t=0}^{\\infty} \\mu_t \\left( a_t - a_{t+1} \\right)\n\\tag{4}\n此时对 c_t 求导得：\n\n\\frac{\\partial \\mathcal{H_t}}{\\partial c_t} = 0\n\\tag{5}\n对 a_t 求导得： \n\\frac{\\partial \\mathcal{H_t}}{\\partial a_t} = -(\\mu_t - \\mu_{t-1})\n\\tag{6}\n这里 -(\\mu_t - \\mu_{t-1}) 类比 -\\dot{\\mu_t}。\n对 \\mu_t 求导得：\n\n\\frac{\\partial \\mathcal{H_t}}{\\partial \\mu_t} = a_{t+1} - a_{t}\n\\tag{7}\n这里 a_{t+1} - a_{t} 类比 \\dot{a_t}。\nTVC:\n\n\\lim_{T \\to \\infty} \\mu_Ta_{T+1} = 0\n\\tag{8}\n注意到，我们已经得到了离散时间版本的 Pontryagin’s maximum principle。"
  },
  {
    "objectID": "posts/2025-09-08-l-h/index.html",
    "href": "posts/2025-09-08-l-h/index.html",
    "title": "从 Lagrangian 到 Hamiltonian",
    "section": "",
    "text": "相较于严格陈述 Pontryagin’s maximum principle，通过类比离散时间的最优化问题并建立与连续时间情形的联系有时候可以提供更好的直觉。当然抛开上述说辞，借用经典笑话，因为 life is hard，一个 heuristic 的证明已经足够。\n我们以一个离散时间的消费储蓄问题为例，为简化起见，假设利率以及消费者的收入都是常数：\n\n\\begin{align*}\n    &\\max_{ \\{c_t, a_{t+1}\\}_{t=0}^{\\infty} } \\sum_{t=0}^{\\infty} \\beta^t u(c_t) \\\\[1ex]\n    &\\text{s.t.} \\quad c_t + a_{t+1} = (1 + r)a_t + y \\enspace \\forall t \\ge 0, \\\\[1ex]\n    &\\ a_0 \\ \\text{is given} ,\\\\\n    &\\ \\text{nPg:} \\ \\lim_{T \\to \\infty} \\frac{a_{T+1}}{(1+r)^T} \\ge 0\n\\end{align*}\n\\tag{1}\n此时，我们可以构造标准的 Lagrangian 并通过求一阶条件得到欧拉方程：\n\n\\mathcal{L} = \\sum_{t=0}^{\\infty} \\beta^t u(c_t) + \\sum_{t=0}^{\\infty} \\mu_t \\left( (1+r)a_t + w - c_t - a_{t+1} \\right)\n\\tag{2}\n但我们舍近求远，定义 Hamiltonian 如下：\n\n\\mathcal{H_t} \\equiv \\beta^t u(c_t) + \\mu_t(ra_t + w - c_t)\n\\tag{3}\n这时原 Lagrange (1) 可以改写为：\n\n\\mathcal{L} = \\sum_{t=0}^{\\infty} \\mathcal{H_t} + \\sum_{t=0}^{\\infty} \\mu_t \\left( a_t - a_{t+1} \\right)\n\\tag{4}\n此时对 c_t 求导得：\n\n\\frac{\\partial \\mathcal{H_t}}{\\partial c_t} = 0\n\\tag{5}\n对 a_t 求导得： \n\\frac{\\partial \\mathcal{H_t}}{\\partial a_t} = -(\\mu_t - \\mu_{t-1})\n\\tag{6}\n这里 -(\\mu_t - \\mu_{t-1}) 类比 -\\dot{\\mu_t}。\n对 \\mu_t 求导得：\n\n\\frac{\\partial \\mathcal{H_t}}{\\partial \\mu_t} = a_{t+1} - a_{t}\n\\tag{7}\n这里 a_{t+1} - a_{t} 类比 \\dot{a_t}。\nTVC:\n\n\\lim_{T \\to \\infty} \\mu_Ta_{T+1} = 0\n\\tag{8}\n注意到，我们已经得到了离散时间版本的 Pontryagin’s maximum principle。"
  },
  {
    "objectID": "posts/2025-09-04-pd/index.html",
    "href": "posts/2025-09-04-pd/index.html",
    "title": "Phase Diagram",
    "section": "",
    "text": "Phase diagram 是用来可视化系统随时间演化的绝佳手段，这里我们通过可视化经济学经典的RCK模型来说明 phase diagram 的含义。\n一个典型的连续时间新古典增长模型最终的一般均衡结果通常可以由下述的微分方程组描述：\n\n\\begin{align*}\n    \\dot{k}(t) &= f(k(t)) - (n + g)k(t) - c(t) \\\\\n    \\dot{c}(t) &= c(t)(f'(k(t)) - \\rho - g) \\\\[1ex]\n    \\text{with} \\enspace &k(0) = k_0 &gt; 0, \\enspace \\lim_{t \\to \\infty} k(t) \\exp(-\\int_{0}^{t} (f'(k(s)) - n - g) \\, ds) = 0 \\\\\n    &k(t) \\ge 0, \\enspace c(t) \\ge 0\n\\end{align*}\n\\tag{1}\n这个两变量的一阶微分方程组实际上定义了一个从 \\mathbb{R}_+^2 到 \\mathbb{R}^2 的映射，即给定任意的 (k, c)\\in\\mathbb{R}_+^2， 对应于一个新的向量 (\\dot{k},\\dot{c})\\in\\mathbb{R}^2。 从几何的角度来看，这正是一个向量场：想象每一个二维平面正象限的点上都附着了一个新的向量，这个向量正好是 k(t) 和 c(t) 对时间的导数，因此这个向量的方向决定了这个点当前运动的方向，这个向量的大小决定了这个点运动速度的大小。\n我们使用quiver()将这一向量场在 (k, c) 所在的二维平面上可视化出来：\n\n\nCode\n# %%\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\nfrom numpy.linalg import eig\nfrom matplotlib.animation import FuncAnimation\nimport warnings\n\n# 忽略 Matplotlib 可能产生的一些用户警告\nwarnings.filterwarnings(\"ignore\", category=UserWarning)\n\n# 确保 Pillow 库已安装\ntry:\n    import PIL\nexcept ImportError:\n    print(\"请安装 Pillow 库: pip install Pillow\")\n    exit()\n\n# 提高 Agg 后端的内存限制，以处理复杂的动画帧\nplt.rcParams['agg.path.chunksize'] = 10000\n\n# %%\n# 定义微分方程组\ndef rck(state, t, alpha, rho, n, g):\n    k, c = state\n\n    # 添加安全检查，防止 k 变为负数导致数学错误\n    if k &lt;= 0:\n        return [0, 0] # 如果 k 非正，则停止运动\n    \n    dkdt = k**alpha - c - (n + g)*k\n    dcdt = c*(alpha*k**(alpha-1) - rho - g)\n    return [dkdt, dcdt]\n\n# %%\n# 定义参数\nalpha, rho, n, g = 0.3, 0.03, 0.02, 0.02\n\n# %%\n# 计算稳态\nk_right = (1/(n+g))**(1/(1-alpha))\nk_gloden = (alpha/(n+g))**(1/(1-alpha))\nc_gloden = k_gloden**alpha - (n + g)*k_gloden\nk_star = (alpha / (rho + g))**(1 / (1 - alpha))\nc_star = k_star**alpha - (n + g) * k_star\n\n# %%\n# 计算 Jacobian 矩阵及其特征值和特征向量\ndef rck_jacobian(k, c, alpha, rho, n, g):\n    # 计算雅可比矩阵的四个元素\n    dk_dot_dk = alpha * k**(alpha - 1) - (n + g)\n    dk_dot_dc = -1.0\n    \n    dc_dot_dk = c * (alpha * (alpha - 1) * k**(alpha - 2))\n    # 在稳态处，(alpha*k**(alpha-1) - rho - delta - theta*g) = 0\n    # 所以 dc_dot/dc = 0，这是 RCK 线性化的一个特点\n    dc_dot_dc = 0.0 \n    \n    return np.array([[dk_dot_dk, dk_dot_dc], [dc_dot_dk, dc_dot_dc]])\n\n#在稳态点计算雅可比矩阵\nJ = rck_jacobian(k_star, c_star, alpha, rho, n, g)\n\n# 计算特征值和特征向量\neigenvalues, eigenvectors = eig(J)\n\n# 找到稳定特征向量 (与负特征值对应的那个)\nstable_eigenvector = eigenvectors[:, np.argmin(eigenvalues)]\n\n# %%\n# 计算 saddle path\nsaddle_point = [k_star, c_star]\nt_backward = np.linspace(0, -100, 600)\npath_saddle_up = odeint(rck, saddle_point + 0.1 * stable_eigenvector, t_backward, args=(alpha, rho, n, g))\npath_saddle_down = odeint(rck, saddle_point - 0.1 * stable_eigenvector, t_backward, args=(alpha, rho, n, g))\npath_saddle_up = np.flipud(path_saddle_up)\npath_saddle_down = np.flipud(path_saddle_down)\n\n# %%\n# 计算背景向量场\nk_grid = np.linspace(0.01, k_right*1.05, 20)\nc_grid = np.linspace(0.01, c_gloden*1.8, 20)\nK, C = np.meshgrid(k_grid, c_grid)\nu, v = np.zeros(K.shape), np.zeros(C.shape)\nfor i in range(K.shape[0]):\n    for j in range(K.shape[1]):\n        dkdt, dcdt = rck([K[i, j], C[i, j]], 0, alpha, rho, n, g)\n        u[i, j] = dkdt\n        v[i, j] = dcdt\n\n# 初始化图像，并设置背景为透明\nfig, ax = plt.subplots(figsize=(6, 5))\nfig.tight_layout()  # 调整边距\nfig.patch.set_alpha(0.0)\nax.patch.set_alpha(0.0)\nax.set_xlim(0, k_right*1.05)\nax.set_ylim(0, c_gloden*1.8)\nax.set_xlabel('k')\nax.set_ylabel('c')\n\n# %%\n# 绘制 loci：dkdt=0，dcdt=0\nx = np.linspace(0, k_right*1.05, 200)\ny = x**alpha - (n + g)*x\nax.plot(x, y, \n        color='black',\n        linestyle='-', \n        linewidth=1.5)\nax.axvline(x = k_star, color= 'black',linestyle='-', linewidth=1.5)\n\n# %%\n# 绘制 saddle path\nax.plot(path_saddle_up[:,0], path_saddle_up[:,1],\n        color='black',\n        linestyle='-', \n        linewidth=1.8)\n\nax.plot(path_saddle_down[:,0], path_saddle_down[:,1],\n        color='black',\n        linestyle='-', \n        linewidth=1.8)\n\n# 绘制向量场\nquiv = ax.quiver(K, C, u, v, \n                     color='gray', \n                     alpha=0.6,\n                     angles='xy',\n                     scale_units='xy',\n                     scale=0.5,\n                     width=0.005)\n\nplt.savefig('rck_quiver.png', bbox_inches='tight')\nplt.close(fig)\n\n\n\n想象我们向这个二维平面中抛入一个小球，图中的每一个箭头都指示了如果小球到达该位置时，这个小球接下来将会如何运动。当小球按照箭头连续地运动起来，它的的运动轨迹便构成了流线，我们使用streamplot()将这些流线可视化：\n\n\nCode\n# %%\n# 计算背景向量场\nk_grid = np.linspace(0.01, k_right*1.05, 100)\nc_grid = np.linspace(0.01, c_gloden*1.8, 100)\nK, C = np.meshgrid(k_grid, c_grid)\nu, v = np.zeros(K.shape), np.zeros(C.shape)\nfor i in range(K.shape[0]):\n    for j in range(K.shape[1]):\n        dkdt, dcdt = rck([K[i, j], C[i, j]], 0, alpha, rho, n, g)\n        u[i, j] = dkdt\n        v[i, j] = dcdt\n\n# 初始化图像，并设置背景为透明\nfig, ax = plt.subplots(figsize=(6, 5))\nfig.tight_layout()  # 调整边距\nfig.patch.set_alpha(0.0)\nax.patch.set_alpha(0.0)\nax.set_xlim(0, k_right*1.05)\nax.set_ylim(0, c_gloden*1.8)\nax.set_xlabel('k')\nax.set_ylabel('c')\n\n# %%\n# 绘制 loci：dkdt=0，dcdt=0\nx = np.linspace(0, k_right*1.05, 200)\ny = x**alpha - (n + g)*x\nax.plot(x, y, \n        color='black',\n        linestyle='-', \n        linewidth=2)\nax.axvline(x = k_star, color= 'black',linestyle='-', linewidth=1.5)\n\n# %%\n# 绘制 saddle path\nax.plot(path_saddle_up[:,0], path_saddle_up[:,1],\n        color='black',\n        linestyle='-', \n        linewidth=1.8)\n\nax.plot(path_saddle_down[:,0], path_saddle_down[:,1],\n        color='black',\n        linestyle='-', \n        linewidth=1.8)\n\n# %%\n# 绘制流线图\nstrm = ax.streamplot(K, C, u, v, \n                     color=(0.4, 0.4, 0.4, 0.4), \n                     linewidth=1.2, \n                     density=1.2,)\n\nplt.savefig('rck_stream.png')\nplt.close(fig)\n\n\n\n直观感受，此时的二维平面像是充满了流动的液体，其流动的规则由我们的微分方程组描述。进一步，想象我们向其中抛入一堆小球，让我们用FuncAnimation()将这些小球的运动可视化：\n\n\nCode\n# %%\n# 计算粒子运动轨迹\n\n# 在 k 轴上从接近 0 到 k_max 创建 4 个均匀分布的点\nk_ticks = np.linspace(5, 60, 4)\n\n# 在 c 轴上从接近 0 到 c_max 创建 4 个均匀分布的点\nc_ticks = np.linspace(0.25, 2.5, 4)\n\n# K 和 C 都将是 4x4 的矩阵\nK_grid, C_grid = np.meshgrid(k_ticks, c_ticks)\n\n# K_grid.flatten() 会将 4x4 的 K 矩阵变成一个 16x1 的向量\n# C_grid.flatten() 会将 4x4 的 C 矩阵变成一个 16x1 的向量\nk_initial = K_grid.flatten()\nc_initial = C_grid.flatten()\n\n# 使用 column_stack 将它们合并成一个 16x2 的矩阵\ninitial_states = np.column_stack([k_initial, c_initial])\n\nt = np.linspace(0, 50, 300)\npaths = [odeint(rck, state, t, args=(alpha, rho, n, g)) for state in initial_states]\n\n# %%\npaths.append(path_saddle_up[100:400, :])\npaths.append(path_saddle_down[150:450, :])\n\n# %%\n# 创建动画元素和更新函数\nparticles, = ax.plot([], [], \"ro\", ms=4)\n\ndef update(frame):\n    x_data = [p[frame, 0] for p in paths]\n    y_data = [p[frame, 1] for p in paths]\n    particles.set_data(x_data, y_data)\n    return particles,\n\n# 创建动画对象\nani = FuncAnimation(fig, update, frames=len(t), interval=20, blit=True)\n\n# 保存动画为 APNG 文件\nani.save(\n    \"rck_animation.png\",\n    writer='pillow',\n    fps=50,\n    savefig_kwargs={'transparent': True, 'facecolor': 'none'}\n)\n\n\n\n目前为止我们只用到了我们完整的均衡描述(1)的前两个运动方程，即任意给定小球的初始位置 (k(0),c(0))\\in\\mathbb{R}_+^2，小球会如何运动下去。换言之，图中任何一个小球的运动轨迹都是这个微分方程组的解，对于这个两变量的一阶微分方程组，我们需要给定两个初始条件才能唯一地确定一个解。\n但注意到，我们RCK模型的解的描述中似乎只有一个初始条件 k(0)=k_0 &gt; 0，另一个初始条件是什么？答案是 \\lim_{t \\to \\infty} k(t) \\exp(-\\int_{0}^{t} (f'(k(s)) - n - g) \\, ds) = 0，虽然将之称为边界条件或者终点条件更为合适，但它确实也是某种意义上的“初始条件”。事实上，对于任意给定的初始资本 k(0)=k_0 &gt; 0 ，这个边界条件反过来唯一地确定了初始消费 c(0) 的取值，这唯一的对应关系构成了从状态变量 k 到控制变量 c 的对应关系 c=g(k)，称之为 policy function，体现在图中便是我们的 saddle path，这背后是家庭的最优化行为。\n从图中可以很清晰地看到，任何在 saddle path 上方的小球最终会运动到左上角，任何在 saddle path 下方的小球最终会运动到右下角，他们看起来都是不合理的解，只有刚好在 saddle path 上的小球最终会沿着这条唯一确定的最优路径抵达稳态，值得注意的是即使是初始值非常微小的偏差，最终也会发散。\n虽然左上角和右下角直觉上都是不合理的区域，但我们最终一般均衡的描述(1)应当自包含了唯一正确的解，如何严格排除其他不合理的解？\n可以验证：\n\n右下角最终会违反 \\lim_{t \\to \\infty} k(t) \\exp(-\\int_{0}^{t} (f'(k(s)) - n - g) \\, ds) = 0\n左上角最终会使得 k(t) 为负，违反了物理约束 k(t) \\ge 0"
  },
  {
    "objectID": "posts/2025-09-15-rcm-nt/index.html",
    "href": "posts/2025-09-15-rcm-nt/index.html",
    "title": "Rubin因果模型：一个符号上的Tip",
    "section": "",
    "text": "标准的 Rubin 潜在结果框架通常都使用 Y_i(1) 和 Y_i(0) 指示个体 i 是/否接受了处置 D_i 的潜在结果，这套符号虽然简洁，但在某些时候会造成一些困惑。Bruce E. Hansen 的 Econometrics 教材提供了一套更为清晰的符号，使得 Rubin 潜在结果框架和经典的计量经济学之间的联系更为直接。\n具体而言，假设个体 i 的结果 Y_i 可以由如下的结构模型描述：\n\nY_i = h(D_i,U_i)\n\\tag{1}\n其中 D_i 与标准符号的含义相同，是代表个体是否接受处置的二元变量。U_i 则代表了所有可能影响结果 Y_i 的其他变量，在这里假设是一个 \\ell \\times 1 的随机向量。h(\\cdot) 代表从 (D_i,U_i) 到 Y_i 的映射关系，但我们不需要对 h(\\cdot) 的函数形式做任何假设，因此 h(\\cdot) 在这里唯一的作用是假设这样的映射关系是存在的。\n在上述意义下 Y_i(1) 实际上是 h(1,U_i)，Y_i(0) 实际上是 h(0,U_i)，而个体 i 的 treament effect 则是：\n\nTE(U_i) = Y_i(1) - Y_i(0) = h(1,U_i) - h(0,U_i)\n\\tag{2}\n即在控制所有其他影响因素 U_i 不变的情况下，改变 D_i 导致的结果差异。\n注意到，由于我们目前只在总体层面考虑问题，因此我们可以去掉下标 i：\n\nY = h(D,U)\n\\tag{3}\n于是 average treatment effect (ATE) 实际上是：\n\n\\mathbb{E}[TE(U)] = \\int_{\\mathbb{R}^{\\ell}} TE(u) f(u)du = \\int_{\\mathbb{R}^{\\ell}} (h(1,u) - h(0,u))f(u)du\n\\tag{4}\n问题的关键在于，通过 Y 对 D 回归得到的系数：\n\n\\mathbb{E}[Y|D=1] - \\mathbb{E}[Y|D=0] = \\int_{\\mathbb{R}^{\\ell}} h(1,u)f(u|D=1)du - \\int_{\\mathbb{R}^{\\ell}} h(0,u)f(u|D=0)du\n\\tag{5}\n是否等于 ATE ？\n不难看出当 D 统计独立于 U 时，即当 f(u|D=1) = f(u|D=0) = f(u) 时两者相等。这实际上就是要求接受处置与否是随机分配的，我们无法从个体是否接受了处置这一信息推断出该个体的其他特征。并且注意到，在上述仅包含 dummy 的回归中， Y 关于 D 的条件期望函数就是线性的，也即在这种特殊情况下，我们的线性条件期望函数是正确设定的。\n\n\n\n\n\n\n如果 D 是 dummy，那么 \\mathbb{E}[Y|D] = \\alpha + \\beta D\n\n\n\n由于 D 的取值只有0和1，显然有：\n\n\\mathbb{E}[Y|D] = \\mathbb{E}[Y|D=0] + (\\mathbb{E}[Y|D=1] - \\mathbb{E}[Y|D=0])D\n\n此时 \\alpha = \\mathbb{E}[Y|D=0]，\\beta = \\mathbb{E}[Y|D=1] - \\mathbb{E}[Y|D=0]。\n\n\n通常我们还会区分所谓的 average treatment effect on the treated (ATET) 以及 average treatment effect on the untreated (ATEU)，在当前符号下，我们很容易看出当随机分配满足，即 D 独立于 U 时，ATE = ATET = ATEU，因为：\n\n\\mathbb{E}[TE(U)|D=1] = \\mathbb{E}[TE(U)|D=0] = \\mathbb{E}[TE(U)]\n\\tag{6}"
  },
  {
    "objectID": "posts/2025-10-03-o-do-m/index.html",
    "href": "posts/2025-10-03-o-do-m/index.html",
    "title": "Overview: Dynamic Optimization in Macro",
    "section": "",
    "text": "Moll(2014) 一图流概况了宏观经济学中的动态优化方法。总结来说，离散时间下的 sequencial method: Lagrangian(classical) 最为直接和直观，即他是直接从全局考虑哪一个 sequence \\{x_t\\}_{t=0}^\\infty 能达到最优的目标，但是最优的 sequence \\{x_t^*\\}_{t=0}^\\infty 本身并不是完全没有规律的，事实上它在宏观经济中的典型优化问题中总能被一组递归的函数关系描述，因此求解整个 sequence 就等价于去求解那个递归函数关系，然后给定初始值 x_0，我们就可以通过那个递归关系还原出整个序列。当然最优的 sequence 存在的递归结构继承自原始的那个优化问题本身的递归结构，这便是所谓 recursive way 的含义。直观来看，我们是将制定一个全局的最优行动计划（sequence）转变为制定一个在每个状态下对应的最优行动指南（policy function）。\n离散时间的形式更为符合直觉，连续时间具有更好的数学性质但理解起来也更为抽象。因此接下来我们会先从离散时间情形出发，再逐步过渡到连续时间情形，以更好看到比较抽象的 Hamiltonian 和 HJB equation 是如何与经典的 Lagrangian 和 Bellman equation 对应的。\n具体而言，我们通过宏观经济学中遇到的典型最优控制问题来说明上面表格中各种概念之间的联系。由于我们的目标是建立直观的联系，所以接下来的推导基本是 heuristic 的，很多技术细节被隐去，同时我们只考虑平稳的（时间 t 不作为状态变量）、确定性的优化问题。最后为了符号上的展示方便，我们只考虑单变量情形（一个状态变量，一个控制变量），推广到多变量情形是自然的，基本只需要把偏导替换为梯度，乘积替换为内积。"
  },
  {
    "objectID": "posts/2025-10-03-o-do-m/index.html#footnotes",
    "href": "posts/2025-10-03-o-do-m/index.html#footnotes",
    "title": "Overview: Dynamic Optimization in Macro",
    "section": "Footnotes",
    "text": "Footnotes\n\n\n这里我们还隐含假设了最优解是内点解，经济学模型通常都会通过施加 Innada condition 来避免边角解的麻烦，否则我们需要将一阶条件写成 complementary slackness 的形式。↩︎"
  }
]